# ('fileName' in the case of debugSource, 'path' in the case of
# testthat::source_file) has been evaluated (forced). For example, the
# following is an inappropriate source call:
#
# source(this.path())
#
# The argument 'file' is stored as a promise containing the expression
# this.path(). When the value of 'file' is requested, it assigns the value
# returned by evaluating this.path() to variable 'file'
#
# There are two functions on the calling stack at this point being source
# and this.path. Clearly, you don't want to request the 'file' argument from
# that source call because the value of 'file' is under evaluation right
# now! The trick is to ask if a variable exists in that function's
# evaluation environment that is only created AFTER 'file' has been forced.
# For base::source, we ask if variable 'ofile' exists. For base::sys.source
# and testthat::source_file, we ask if variable 'exprs' exists. For
# debugSource, we cannot use this trick. Refer to the documentation below.
#
# If that variable exists, then argument 'file' has been forced and the
# source call is deemed appropriate. If that variable does not exist, then
# argument 'file' has not been forced and the source call is deemed
# inappropriate. The loop continues to the next iteration (if available)
## as of this.path_0.2.0, compatibility with 'debugSource' from the
## 'RStudio' environment was added. 'debugSource' presents challenges that
## other source functions do not. For example, it is impossible to test if
## argument 'fileName' has been forced since all of the work is done
## internally in C. This is why we use a 'tryCatch' statement instead of an
## 'existsn'
dbs <- if (.Platform$GUI == "RStudio")
get("debugSource", mode = "function", "tools:rstudio",
inherits = FALSE)
## as of this.path_0.4.0, compatibility with 'source_file' from package
## 'testthat' was added. 'testthat::source_file' is almost identical to
## 'base::sys.source' except that, strangely enough, it does not have the
## issue when sourcing a file named 'clipboard' ('base::sys.source' does
## have this issue where it tries to source the clipboard instead of the
## file named 'clipboard'. You might ask "why are you even concerned about
## this case, who would name a file 'clipboard'?", and that's a valid
## question, and I don't really have an answer. I was just messing around
## when I found this, so I accounted for it, despite how little it will
## occur, because I wanted to).
sf <- if (isNamespaceLoaded("testthat"))
getExportedValue("testthat", "source_file")
for (n in seq.int(sys.nframe(), 1L)[-1L]) {
if (identical(sys.function(n), base::source)) {
## if the argument 'file' to 'base::source' has not been forced,
## continue to the next iteration
if (!existsn("ofile"))
next
## if the path has yet to be saved
if (!existsn("__file__")) {
## retrieve the unmodified 'file' argument
path <- getn("ofile")
## as of this.path_0.3.0, compatibility was added when using
## 'base::source' with argument 'chdir' set to TRUE.
## this changes the working directory to the directory of the
## 'file' argument. since the 'file' argument was relative to
## the working directory prior to being changed, we need to
## change it to the previous working directory before we can
## open a connection (if necessary) and normalize the path
if (existsn("owd")) {
cwd <- getwd()
on.exit(setwd(cwd))
setwd(getn("owd"))
}
## there are two options for 'file'
## * connection
## * character string
## start with character string
if (is.character(path)) {
## use of "" refers to the R-level 'standard input' stdin.
## this means 'base::source' did not open a file, so we assign
## __file__ the value of NULL and continue to the next
## iteration. We use __file__ as NULL to skip this source call
## the next time this.path leads here
if (path == "") {
assign.__file__(NULL)
next
}
## as of this.path_0.4.3, the path is determined slightly
## differently. this change is to account for two possible
## scenarios
## * source("file://absolute or relative path")
## * source("file:///absolute path")
## the description of this connection should remove the
## leading characters
con <- file(path, "r")
on.exit(close(con), add = TRUE)
path <- summary.connection(con)$description
if (existsn("owd"))
on.exit(setwd(cwd))
else on.exit()
close(con)
}
else path <- summary.connection(path)$description
## use of "clipboard" and "stdin" refer to the clipboard or to
## the C-level 'standard input' of the process, respectively.
## this means 'base::source' did not open a file, so we assign
## __file__ the value of NULL and continue to the next
## iteration. We use __file__ as NULL to skip this source call
## the next time this.path leads here
if (path %in% c("clipboard", "stdin")) {
assign.__file__(NULL)
next
}
## assign __file__ as the absolute path
assign.__file__()
}
else if (is.null(getn("__file__")))
next
where("call to function source")
return(getn("__file__"))
}
else if (identical(sys.function(n), base::sys.source)) {
## as with 'base::source', we check that argument 'file' has been
## forced, and continue to the next iteration if not
if (!existsn("exprs"))
next
## much the same as 'base::source' except simpler, we don't have to
## account for argument 'file' being a connection or ""
if (!existsn("__file__")) {
path <- getn("file")
if (existsn("owd")) {
cwd <- getwd()
on.exit(setwd(cwd))
setwd(getn("owd"))
}
## unlike 'base::source', 'base::sys.source' is intended to
## source a file (not a connection), so we have to throw an
## error if the user attempts to source a file named "clipboard"
## or "stdin" since both of these DO NOT refer to files
if (path %in% c("clipboard", "stdin"))
stop(errorCondition("invalid 'file' argument, must not be \"clipboard\" nor \"stdin\"",
call = sys.call(n)))
assign.__file__()
}
where("call to function sys.source")
return(getn("__file__"))
}
else if (identical(sys.function(n), dbs)) {
## unlike 'base::source' and 'base::sys.source', there is no way to
## check that argument 'fileName' has been forced, since all of the
## work is done internally in C. Instead, we have to use a
## 'tryCatch' statement. If argument 'fileName' has been forced, the
## statement will proceed without an issue. If it has not, it is
## because argument 'fileName' depends on itself recursively with
## message "promise already under evaluation: recursive default
## argument reference or earlier problems?". If you'd like to see,
## try this:
##
## test <- function() get("fileName", sys.frame(1), inherits = FALSE)
## debugSource(test())
##
## and you should see the error in which I'm referring. So the trick
## is to use the 'tryCatch' statement to request argument
## 'fileName', return TRUE if the statement proceeded without error
## and FALSE if the statement produced an error.
cond <- tryCatch({
path <- getn("fileName")
TRUE
}, error = function(c) FALSE)
if (!cond)
next
if (!existsn("__file__")) {
## we have to use 'enc2utf8' because 'debugSource' does as well
path <- enc2utf8(path)
if (path == "") {
assign.__file__(NULL)
next
}
con <- file(path, "r")
on.exit(close(con))
path <- summary.connection(con)$description
on.exit()
close(con)
if (path %in% c("clipboard", "stdin")) {
assign.__file__(NULL)
next
}
assign.__file__()
}
else if (is.null(getn("__file__")))
next
where("call to function debugSource in RStudio")
return(getn("__file__"))
}
else if (identical(sys.function(n), sf)) {
## as with 'base::source' and 'base::sys.source', we check that
## argument 'path' has been forced, and continue to the next
## iteration if not
if (!existsn("exprs"))
next
if (!existsn("__file__")) {
path <- getn("path")
if (existsn("old_dir")) {
cwd <- getwd()
on.exit(setwd(cwd))
setwd(getn("old_dir"))
}
## like 'base::sys.source', 'testthat::source_file' is intended
## to source a file (not a connection), so we have to throw an
## error if the user attempts to source a file named "clipboard"
## or "stdin" since both of these DO NOT refer to files
if (path == "stdin")
stop(errorCondition("invalid 'path' argument, must not be \"clipboard\" nor \"stdin\"",
call = sys.call(n)))
assign.__file__()
}
where("call to function source_file in package testthat")
return(getn("__file__"))
}
}
# if the for loop is passed, no appropriate
# source call was found up the calling stack
#
# next, check how R is being run
#
# * from Windows command-line or Unix terminal
# * from Unix terminal with GUI 'Tk' (was treated as an unrecognized manner
#       until this.path_0.5.0)
# * from 'RStudio'
# * from 'RGui' on Windows (added in this.path_0.2.0)
# * from 'RGui' on macOS (also called 'AQUA'), signal an error
# * unrecognized manner, signal an error
if (.Platform$OS.type == "windows" && .Platform$GUI == "RTerm" ||  # running from Windows command-line
.Platform$OS.type == "unix" && .Platform$GUI == "X11") {       # running from Unix terminal with default GUI
if (is.null(`__file__`))
stop("'this.path' used in an inappropriate fashion\n",
"* no appropriate source call was found up the calling stack\n",
"* R is being run from the command-line and argument 'FILE' is missing")
where("command-line argument 'FILE'")
return(`__file__`)
}
# running from Unix terminal with GUI 'Tk'
else if (.Platform$OS.type == "unix" && .Platform$GUI == "Tk") {
stop("'this.path' used in an inappropriate fashion\n",
"* no appropriate source call was found up the calling stack\n",
"* R is being run from Tk which requires a source call on the calling stack")
}
# running from 'RStudio'
else if (.Platform$GUI == "RStudio") {
# function ".rs.api.getActiveDocumentContext" from the environment
# "tools:rstudio" returns a list of information about the document where
# your cursor is located
#
# function ".rs.api.getSourceEditorContext" from the environment
# "tools:rstudio" returns a list of information about the document open
# in the current tab
#
# element 'id' is a character string, an identification for the document
# element 'path' is a character string, the path of the document
adc <- get(".rs.api.getActiveDocumentContext", mode = "function",
"tools:rstudio", inherits = FALSE)()
if (adc$id != "#console") {
path <- adc$path
if (nzchar(path)) {
where("active document in RStudio")
return(normalizePath2(path, mustWork = FALSE))
}
else stop("'this.path' used in an inappropriate fashion\n",
"* no appropriate source call was found up the calling stack\n",
"* active document in RStudio does not exist")
}
sec <- get(".rs.api.getSourceEditorContext", mode = "function",
"tools:rstudio", inherits = FALSE)()
if (!is.null(sec)) {
path <- sec$path
if (nzchar(path)) {
where("source document in RStudio")
return(normalizePath2(path, mustWork = FALSE))
}
else stop("'this.path' used in an inappropriate fashion\n",
"* no appropriate source call was found up the calling stack\n",
"* source document in RStudio does not exist")
}
else stop("'this.path' used in an inappropriate fashion\n",
"* no appropriate source call was found up the calling stack\n",
"* R is being run from RStudio with no documents open")
}
# running from 'RGui' on Windows
else if (.Platform$OS.type == "windows" && .Platform$GUI == "Rgui") {
# on a Windows OS only, the function "getWindowsHandles" from the base
# package "utils" returns a list of external pointers containing the
# windows handles. The thing of interest are the names of this list,
# these should be the names of the windows belonging to the current R
# process. Since 'RGui' can have files besides R scripts open (such as
# images), a regular expression is used to subset only windows handles
# with names that exactly match the string "R Console" or end with
# " - R Editor". I highly suggest that you NEVER end a document's
# filename with " - R Editor". From there, similar checks are done as in
# the above section for 'RStudio'
wh <- names(utils::getWindowsHandles(pattern = "^R Console$| - R Editor$",
minimized = TRUE))
if (!length(wh))
stop("no windows in RGui; should never happen, please report!")
path <- wh[1L]
if (path != "R Console") {
path <- sub(" - R Editor$", "", path)
if (path != "Untitled") {
where("active document in RGui")
return(normalizePath2(path, mustWork = FALSE))
}
else stop("'this.path' used in an inappropriate fashion\n",
"* no appropriate source call was found up the calling stack\n",
"* active document in RGui does not exist")
}
path <- wh[2L]
if (!is.na(path)) {
path <- sub(" - R Editor$", "", path)
if (path != "Untitled") {
where("source document in RGui")
return(normalizePath2(path, mustWork = FALSE))
}
else stop("'this.path' used in an inappropriate fashion\n",
"* no appropriate source call was found up the calling stack\n",
"* source document in RGui does not exist")
}
else stop("'this.path' used in an inappropriate fashion\n",
"* no appropriate source call was found up the calling stack\n",
"* R is being run from RGui with no documents open")
}
# running from 'RGui' on macOS
else if (capabilities("aqua") && .Platform$GUI == "AQUA") {
stop("'this.path' used in an inappropriate fashion\n",
"* no appropriate source call was found up the calling stack\n",
"* R is being run from AQUA which requires a source call on the calling stack")
}
# running R in another manner
else stop("'this.path' used in an inappropriate fashion\n",
"* no appropriate source call was found up the calling stack\n",
"* R is being run in an unrecognized manner")
}
this.dir <- function (verbose = getOption("verbose"))
dirname(this.path(verbose = verbose))
`__file__` <- NULL
path.contract <- function (path)
{
## path.contract {this.path}                                   Documentation
##
##
##
## Contract File Paths
##
##
##
## Description
##
## Contract a path name, for example by replacing the user's home
## directory (if defined on that platform) with a leading tilde.
##
##
##
## Usage
##
## path.contract(path)
##
##
##
## Arguments
##
## path  character vector containing one or more path names.
##
##
##
## Details
##
## The 'path names' need not exists nor be valid path names.
##
##
##
## Value
##
## A character vector of possibly contracted path names: where the home
## directory is unknown or none is specified the path is unchanged.
tilde <- path.expand("~")
if (tilde != "~") {  # if the home directory is defined
path  <- normalizePath(path , winslash = "/", mustWork = FALSE)
tilde <- normalizePath(tilde, winslash = "/", mustWork = FALSE)
contract <- startsWith(path, tilde)
path[contract] <- paste0("~", substr(path[contract],
nchar(tilde) + 1L, 1000000L))
}
path
}
commandPrompt <- function ()
{
# commandPrompt {this.path}                                    Documentation
#
#
#
# Replicate the Command-Line Prompts Seen on a Few Common OS's
#
#
#
# Description
#
# Get the prompt seen at the Windows command-line / / Unix terminal.
# Currently well defined for Windows, macOS, and Ubuntu. All other flavours
# of Linux will return the prompt seen the Ubuntu terminal in hopes that it
# looks similar enough to be understandable.
#
#
#
# Usage
#
# commandPrompt()
#
#
#
# Value
#
# A character string; the command-line / / terminal prompt
wd <- getwd()
if (.Platform$OS.type == "windows") {  # on Windows
if (!is.null(wd))
wd <- normalizePath(wd)
else wd <- "unknown"
sprintf("%s>", wd)
}
else if (capabilities("aqua")) {       # on macOS (see ?capabilities)
if (!is.null(wd)) {
wd <- path.contract(wd)
if (wd != "~")
wd <- basename(wd)
}
else wd <- "unknown"
sys.info <- Sys.info()
nodename <- sub("\\.local$", "", sys.info[["nodename"]])
sprintf("%s:%s %s$ ", nodename, wd, sys.info[["effective_user"]])
}
else {                                 # on any other Linux flavour
if (!is.null(wd))
wd <- path.contract(wd)
else wd <- "unknown"
sys.info <- Sys.info()
sprintf("%s@%s:%s$ ", sys.info[["effective_user"]],
sys.info[["nodename"]], wd)
}
}
## Check This ----
Check_This <- function (with.keep.source = TRUE, no.multiarch = TRUE, as.cran = TRUE)
{
if (!interactive())
return(invisible())
pkg <- basename(dirname(dirname(this.path(verbose = FALSE))))
owd <- getwd()
if (!is.null(owd))
on.exit(setwd(owd))
setwd(dirname(dirname(dirname(this.path(verbose = FALSE)))))
cat("\n")
command <- sprintf("R CMD INSTALL %s", pkg)
if (with.keep.source)
command <- paste(command, "--with-keep.source")
if (no.multiarch)
command <- paste(command, "--no-multiarch")
cat(commandPrompt(), command, "\n\n", sep = "")
system(command)
cat("\n")
command <- sprintf("R CMD build %s", pkg)
cat(commandPrompt(), command, "\n\n", sep = "")
system(command)
command <- sprintf("R CMD check %s_%s.tar.gz", pkg, utils::packageVersion(pkg))
if (as.cran)
command <- paste(command, "--as-cran")
cat(commandPrompt(), command, "\n\n", sep = "")
invisible(system(command))
}
if (interactive()) Check_This(no.multiarch = FALSE)
p <- this.path::ArgumentParser(description = "Process some integers.", style = 2)
p$add.argument("integers", metavariable = "N", type = "integer", nargs = "+",
help = "An integer for the accumulator")
p$add.argument("--sum", destination = "accumulate", action = "store_const",
constant = base::sum, default = base::max,
help = "Sum the integers (default: find the max)")
p$print.help()
p.args <- p$parse.args(c("1", "2", "3", "4"))
print(p.args$accumulate(p.args$integers))
parser <- this.path::ArgumentParser(description = "Process some integers.", style = 2)
parser$add.argument("integers", metavariable = "N", type = "integer", nargs = "+",
help = "An integer for the accumulator")
parser$add.argument("--sum", destination = "accumulate", action = "store_const",
constant = base::sum, default = base::max,
help = "Sum the integers (default: find the max)")
parser$print.help()
parser <- this.path::ArgumentParser(description = "Process some integers.", style = 2)
parser$add.argument("integers", metavariable = "N", type = "integer", nargs = "+",
help = "An integer for the accumulator")
parser$add.argument("--sum", destination = "accumulate", action = "store_const",
constant = base::sum, default = base::max,
help = "Sum the integers (default: find the max)")
parser$print.help()
pargs <- parser$parse.args(c("1", "2", "3", "4"))
print(pargs$accumulate(pargs$integers))
pargs <- parser$parse.args(c("1", "2", "3", "4", "--sum"))$as.list()
function (x, pos = -1L, envir = as.environment(pos), mode = "any",
inherits = TRUE)
parser <- this.path::ArgumentParser(description = "Process some integers.", style = 2)
parser$add.argument("integers", metavariable = "N", type = "integer", nargs = "+",
help = "An integer for the accumulator")
parser$add.argument("--sum", destination = "accumulate", action = "store_const",
constant = base::sum, default = base::max,
help = "Sum the integers (default: find the max)")
parser$print.help()
pargs <- parser$parse.args(c("1", "2", "3", "4"))
print(pargs$accumulate(pargs$integers))
pargs <- parser$parse.args(c("1", "2", "3", "4", "--sum"))
print(pargs$accumulate(pargs$integers))
pargs <- parser$parse.args(c("a", "b", "c"))
print(pargs$accumulate(pargs$integers))
pargs <- parser$parse.args(c("--sum", "7", "-1", "42"))
print(pargs)
